# åŸºç¡€ç®—æ³•

## æ’åº

### å¿«é€Ÿæ’åº

å¿«é€Ÿæ’åºæœ¬è´¨ä¸Šå°±æ˜¯åˆ†æ²»ï¼

1. **ç¡®å®šåˆ†ç•Œç‚¹x**ï¼šå–å·¦è¾¹ç•Œ q[l]ï¼Œæˆ–è€…å–ä¸­é—´å€¼ q[(l+r)/2]ï¼Œæˆ–è€…å–å³è¾¹ç•Œ q[r]ï¼Œä¹Ÿå¯ä»¥éšæœºï¼›
2. **è°ƒæ•´åŒºé—´**(è¾ƒéš¾éƒ¨åˆ†)ï¼šè®©å°äºç­‰äº x çš„æ•°åœ¨ä¸€ä¸ªåŒºé—´ï¼Œå¤§äº x çš„åœ¨å¦ä¸€ä¸ªåŒºé—´
3. **é€’å½’å¤„ç†å·¦å³ä¸¤ç«¯**

**å¹³å‡æ—¶é—´å¤æ‚åº¦**ï¼š O(nlogn)ï¼Œæ¯å±‚æœŸæœ›æ˜¯ n/2 ï¼Œé€’å½’æ·±åº¦ logn

**æ€è·¯1**ï¼ˆæš´åŠ›è§£æ³•ï¼Œéœ€è¦é¢å¤–ç©ºé—´æ”¾a[] b[]ï¼‰

**æ€è·¯2ï¼š**ï¼ˆè¾ƒä¼˜ç¾çš„è§£æ³•ï¼‰
ä½¿ç”¨åŒæŒ‡é’ˆï¼Œä»æ•°ç»„ä¸¤ç«¯å‘ä¸­é—´é æ‹¢ã€‚æŒ‡é’ˆ i ä»å·¦ç«¯æ‰¾å¤§äºç­‰äº x çš„æ•°ï¼ŒæŒ‡é’ˆ j ä»å³ç«¯æ‰¾å°äºç­‰äº x çš„æ•°ï¼Œç„¶åswapäºŒè€…ï¼Œç›´è‡³ i å’Œ j ç›¸é‡ã€‚

```java
int[] quickSort(int[] arr, int l, int r) {
    // é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼Œå¦‚æœå·¦è¾¹ç•Œä¸‹æ ‡å¤§äºç­‰äºå³è¾¹ç•Œä¸‹æ ‡åˆ™è®¤ä¸ºé€’å½’ç»“æŸ
    if (l >= r) {
        return arr;
    }
    // è®¾å®šä¸€ä¸ªåˆ†ç•Œå€¼ï¼Œè¿™é‡Œæ˜¯ï¼ˆleft + rightï¼‰/ 2ï¼Œå‘ä¸‹å–æ•´
    // åŸºå‡†å€¼ä¸€å®šè¦è®¾å®šä¸ºä¸€ä¸ªå…·ä½“çš„æ•°ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªä½ç½®ï¼Œå¦åˆ™äº¤æ¢æ—¶åŸºå‡†å¯èƒ½æ”¹å˜
    int p = arr[l + r >> 1];
    // å·¦å³æå‰é¢„ç•™ä¸€ä¸ªä½ç½®
    int i = left - 1;
    int j = right + 1;
    while (i < j) {
        // ç­‰æ•ˆäºdo while
        // å½“æ•°å€¼å°äºåˆ†ç•Œå€¼æ—¶æŒç»­éå†ï¼Œç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºåˆ†ç•Œå€¼çš„ç´¢å¼•
        while (arr[++i] < p);
        while (arr[--j] > p);
        // äº¤æ¢å·¦å³ä¸¤ä¾§ä¸ç¬¦åˆé¢„æœŸçš„æ•°å€¼
        if (i < j) {
            swap(arr[i], arr[j])
        }
    }
    // ç”±äºåˆ†ç•Œå€¼å–çš„æ˜¯left + right >> 1ï¼Œå› æ­¤é€’å½’å–çš„æ˜¯leftï¼Œj j + 1ï¼Œright
    quickSort(arr, left, j);
    quickSort(arr, j + 1, right);
    return arr;
}
```

### å½’å¹¶æ’åº

å½’å¹¶æ’åºæœ¬è´¨ä¸Šå°±æ˜¯åˆ†æ²»ï¼

**åŸºæœ¬æ€æƒ³**

1. **ç¡®å®šåˆ†ç•Œç‚¹** mid = ( l + r ) / 2ï¼Œåˆ’åˆ† leftã€right
2. **é€’å½’æ’åº** leftï¼Œrightã€‚
3. **å½’å¹¶**â€”â€”åˆäºŒä¸ºä¸€ã€‚ï¼ˆè¾ƒéš¾æ­¥éª¤ï¼‰

**æ—¶é—´å¤æ‚åº¦**ï¼š O(nlogn)

**å¿«æ’æ˜¯ä¸ç¨³å®šçš„ï¼Œå½’å¹¶æ˜¯ç¨³å®šçš„ã€‚**

```java
int[] mergeSort(int[] arr, int l, int r) {
    // é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼Œå¦‚æœå·¦è¾¹ç•Œå¤§äºç­‰äºå³è¾¹ç•Œåˆ™è®¤ä¸ºé€’å½’ç»“æŸ
    if (l >= r) {
        return arr;
    }
    // 1.è®¾å®šä¸€ä¸ªåˆ†ç•Œå€¼ï¼Œè¿™é‡Œæ˜¯ï¼ˆleft + rightï¼‰/ 2
    int m = l + r >> 1;
    // 2.åˆ‡å‰²ï¼Œé€’å½’æ’åº
    arr = mergeSort(arr, l, m);
    arr = mergeSort(arr, m + 1, r);
    // ä¸´æ—¶å­˜æ”¾çš„æ•°ç»„
    int[] temp = new int[r - l + 1];
    // ä¸¤ä¸ªæŒ‡é’ˆ
    int i = l;
    int j = m + 1;
    // ç”¨æ¥å½’å¹¶çš„ç´¢å¼•
    int k = 0;
    // 3.å½’å¹¶
    while (i <= m && j <= r) {
        // å¦‚æœæ˜¯é€†åºåˆ™è°ƒæ•´ifæ¡ä»¶
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    // æ”¶å°¾
    while (i <= m) {
        temp[k++] = arr[i++];
    }
    while (j <= r) {
        temp[k++] = arr[j++];
    }
    // æ ¹æ®å½’å¹¶åçš„æ•°ç»„é‡æ–°èµ‹å€¼æ’åºåçš„æ•°ç»„
    for (i = l, j = 0; i <= r; i++, j++) {
        arr[i] = temp[j];
    }
    return arr;
}
```

## äºŒåˆ†æŸ¥æ‰¾â€”â€”æ‰¾è¾¹ç•Œ

æœ‰å•è°ƒæ€§ä¸€å®šå¯ä»¥äºŒåˆ†ï¼Œä½†æ˜¯å¯ä»¥äºŒåˆ†çš„é¢˜ç›®ä¸ä¸€å®šéè¦æœ‰å•è°ƒæ€§ã€‚
æ ¸å¿ƒï¼šæ‰¾åˆ°ä¸€ä¸ªè¾¹ç•Œå°†åŒºé—´åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä½¿å¾—ä¸€éƒ¨åˆ†æ»¡è¶³ ckeckï¼Œå¦ä¸€éƒ¨åˆ†ä¸æ»¡è¶³ã€‚

### æ•´æ•°äºŒåˆ†

ä¸¤ç§æ¨¡æ¿ï¼Œåˆ†åˆ«æ˜¯ LBSï¼Œå’Œ RBS

```java
// åŒºé—´[left, right]è¢«åˆ’åˆ†æˆ[left, mid]å’Œ[mid + 1, right]æ—¶ä½¿ç”¨ï¼š 
// ç§°ä¹‹ä¸ºå·¦äºŒåˆ†æŸ¥è¯¢ï¼ŒæŸ¥æ‰¾å·¦ä¾§ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„æ•°
int leftBinarySearch(int[] arr, int left, int right) {  
   while (left < right) {  
      int mid = left + right >> 1;  
      if (check(arr[mid])) {  
         right = mid;    // check()åˆ¤æ–­midæ»¡è¶³å³ä¾§æ€§è´¨
      } else {  
         left = mid + 1;  
      }  
   }  
   return left;  
}  
// åŒºé—´[left, right]è¢«åˆ’åˆ†æˆ[left, mid - 1]å’Œ[mid, right]æ—¶ä½¿ç”¨ï¼š  
// ç§°ä¹‹ä¸ºå³äºŒåˆ†æŸ¥è¯¢ï¼ŒæŸ¥æ‰¾å³ä¾§æœ€åä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„æ•°
private static int rightBinarySearch(int[] arr, int left, int right) {  
   while (left < right) {  
      int mid = left + right + 1 >> 1; // å‘ä¸‹å–æ•´ï¼Œæ‰€ä»¥è¦åŠ ä¸€ï¼Œé¿å…æ­»å¾ªç¯ 
      if (check(arr[mid])) {  
         left = mid;    // check()åˆ¤æ–­midæ»¡è¶³å·¦ä¾§æ€§è´¨ 
      } else {  
         right = mid - 1;  // æœ‰åŠ å¿…æœ‰å‡
      }  
   }  
   return left;  
}
```

### æµ®ç‚¹æ•°äºŒåˆ†

double å¯ä»¥ç›´æ¥é™¤è€Œä¸ä¼šå–æ•´ï¼Œæ‰€ä»¥ä¸ç”¨åœ¨æ„è¾¹ç•Œé—®é¢˜ï¼Œè¾ƒä¸ºç®€å•ã€‚
åˆ¤æ–­æ¡ä»¶ä¸€èˆ¬ä¸º r - l >= 1e-6.
æ¬¡æ•°ä¸€èˆ¬å–è¦æ±‚çš„ä¿ç•™å°æ•°ç‚¹ä½æ•°+2ï¼Œä¾‹å¦‚ä¿ç•™5ä½å°æ•°ï¼Œå°±æ˜¯1e-7.

ä¹Ÿå¯ä»¥ä¸ç”¨ whileï¼Œç›´æ¥ for å¾ªç¯100æ¬¡ï¼Œç›¸å½“äºåŒºé—´é™¤ä»¥ 2 çš„100æ¬¡æ–¹ï¼Œå¾—åˆ°çš„ä½æ•°è¶³å¤Ÿã€‚

```java
// æ£€æŸ¥xæ˜¯å¦æ»¡è¶³æŸç§æ€§è´¨  
booleanean check(double x) {  
   /* ... */  
}  

// eps è¡¨ç¤ºç²¾åº¦ï¼Œå–å†³äºé¢˜ç›®å¯¹ç²¾åº¦çš„è¦æ±‚ï¼Œé»˜è®¤è´Ÿå…­æ¬¡æ–¹
double EPS = 1e-6;

double floatBinarySearch(double left, double right) {  
   while (right - left > EPS) {  
      double mid = (left + right) / 2;  
      if (check(mid)) {  
         right = mid;  
      } else {  
         left = mid;  
      }  
   }  
   return left;  
}
```

## é«˜ç²¾åº¦ï¼ˆC++ éœ€è¦ï¼ŒJava å’Œ Python ä¸å…³æ³¨ï¼‰

å¯¹äºä¸€ä¸ªå¤§æ•´æ•°ï¼Œé€šå¸¸ç”¨æ•°ç»„æ¥å­˜ï¼Œé€šå¸¸**ä»ä½ä½å¼€å§‹å­˜**è¾ƒå¥½ã€‚
åŸå› æ˜¯ï¼šå› ä¸ºæ•´æ•°ç›¸åŠ è¦è¿›ä½ï¼Œå½“æœ€é«˜ä½è¦è¿›ä½çš„æ—¶å€™ï¼Œåœ¨æ•°ç»„çš„æœ«å°¾ä½¿ç”¨ push_back() åŠ ä¸€ä½å³å¯ï¼Œè¾ƒæ–¹ä¾¿ã€‚åä¹‹ï¼Œåœ¨å¤´éƒ¨åŠ ä¸€ä½è¦å°†æ•´ä¸ªæ•°ç»„åç§»ï¼Œè¾ƒéº»çƒ¦ã€‚

- é«˜ç²¾åº¦åŠ æ³•
- é«˜ç²¾åº¦å‡æ³•
- é«˜ç²¾åº¦ä¹˜ä½ç²¾åº¦
- é«˜ç²¾åº¦é™¤ä»¥ä½ç²¾åº¦



## å‰ç¼€å’Œä¸å·®åˆ†

### ä¸€ç»´å‰ç¼€å’Œ

S ä¸‹æ ‡ä» 1 å¼€å§‹ï¼Œå®šä¹‰ S[0] = 0ï¼Œæ˜¯ä¸ºäº†åŒä¸€è®¡ç®—

```java
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

### äºŒç»´å‰ç¼€å’Œ

åŒæ ·ä» 1 å¼€å§‹

```java
S[i, j] = ç¬¬iè¡Œjåˆ—æ ¼å­å·¦ä¸Šéƒ¨åˆ†æ‰€æœ‰å…ƒç´ çš„å’Œ
ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µçš„å’Œä¸ºï¼š
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

### ä¸€ç»´å·®åˆ†

å·®åˆ†æ˜¯å‰ç¼€å’Œçš„é€†è¿ç®—ï¼Œå³æ ¹æ®ç»™å‡ºçš„å‰ç¼€å’Œæ±‚åŸæ•°ç»„çš„å€¼ï¼Œè¿™é‡Œæ ¹æ® A[ ] æ•°ç»„ï¼Œæ„é€  B[ ] æ•°ç»„ï¼Œä½¿å¾— A æ˜¯ B çš„å‰ç¼€å’Œã€‚

å·®åˆ†æœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ
å¦‚æœéœ€è¦å°†æ•°ç»„ A[ ] çš„ [ l , r ] åŒºé—´å†…æ‰€æœ‰æ•°éƒ½ + cï¼Œæ“ä½œ A æ•°ç»„æ—¶ï¼Œéœ€è¦éå†ä¸€éï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(n)ã€‚è€Œæ“ä½œ B æ•°ç»„æ—¶ï¼Œåªéœ€è¦å°† $b_l + c$ ï¼Œå°±å¯ä»¥ä½¿çš„ä» a[ l ] åˆ° a[ n ]çš„æ‰€æœ‰æ•°éƒ½åŠ  cï¼Œå†ä½¿ç”¨ $b_{r+1} - c$ï¼Œæ¶ˆé™¤å¯¹ a[ r ]ä¹‹åæ•°çš„å½±å“ï¼Œå°±å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦é™è‡³ O(1)ã€‚

```java
ç»™åŒºé—´ A[l, r]ä¸­çš„æ¯ä¸ªæ•°åŠ ä¸Š cï¼šB[l] += c, B[r + 1] -= c
å·®åˆ†æ„é€ ï¼šB[i] = A[i] - A[i - 1];  
æ›´ç²¾ç®€çš„ï¼Œå¯ä»¥æƒ³è±¡Aåˆå§‹ä¸º0ï¼Œç„¶åä¾æ¬¡æ’å…¥A[i,j]çš„å…ƒç´ ï¼Œå°±å¯ä»¥ç»Ÿä¸€ç†è§£äº†
```

### äºŒç»´å·®åˆ†

```java
ç»™ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ åŠ ä¸Š cï¼š
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```

## åŒæŒ‡é’ˆç®—æ³•

å¯¹äºä»¥å¾€éœ€è¦åŒé‡ for å¾ªç¯æš´åŠ›è§£çš„é¢˜ç›®è¿›è¡Œä¼˜åŒ–ï¼›åœ¨å¿«æ’å’Œå½’å¹¶æ’åºä¸­éƒ½ç”¨åˆ°äº†åŒæŒ‡é’ˆçš„æ€æƒ³ã€‚

æ‰€ä»¥ä¸€èˆ¬åšé¢˜éƒ½æ˜¯å…ˆç”¨æš´åŠ›è§£æ³•æƒ³æ€è·¯ï¼Œå†ç”¨åŒæŒ‡é’ˆä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ã€‚

```java
for (int i = 0, j = 0; i < n; i ++ ) {
    while (j < i && check(i, j)) {
        j ++ ;
    }
    // å…·ä½“é—®é¢˜çš„é€»è¾‘
}
å¸¸è§é—®é¢˜åˆ†ç±»ï¼š
    (1) å¯¹äºä¸€ä¸ªåºåˆ—ï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆç»´æŠ¤ä¸€æ®µåŒºé—´
    (2) å¯¹äºä¸¤ä¸ªåºåˆ—ï¼Œç»´æŠ¤æŸç§æ¬¡åºï¼Œæ¯”å¦‚å½’å¹¶æ’åºä¸­åˆå¹¶ä¸¤ä¸ªæœ‰åºåºåˆ—çš„æ“ä½œ
```

## ä½è¿ç®—

```java
1.æ±‚ n çš„äºŒè¿›åˆ¶ç¬¬ k ä½æ•°å­—: n >> k & 1
2.è¿”å› n çš„äºŒè¿›åˆ¶æœ€åä¸€ä½ 1ï¼šlowbit(n) = n & -n = n & (~n + 1)
å› ä¸ºåç  -n æ˜¯ n çš„è´Ÿæ•°ï¼Œå³ä¸º n çš„è¡¥ç åŠ  1 ï¼š-n = ~n + 1
```

## ç¦»æ•£åŒ–â€”â€”å¤„ç†ç¨€ç–é—®é¢˜

è¿™é‡ŒæŒ‡æ•´æ•°çš„ç¦»æ•£åŒ–ï¼Œä¸”æ˜¯ä¿åºçš„ç¦»æ•£åŒ–ï¼šå°†æ•°ç»„ a[ ] ä¸­çš„æ•°æ˜ å°„åˆ° 0 1 2 3 4 â€¦ è¿™æ ·è¿ç»­çš„è‡ªç„¶æ•°

```
1. a[] ä¸­å¯èƒ½å­˜åœ¨é‡å¤å…ƒç´ ï¼šå»é‡
2. æ’åº
3. å¦‚ä½•ç®—å‡ºæŸä¸€ä¸ªæ•° x ç¦»æ•£åŒ–åçš„æ˜ å°„å€¼ ï¼šäºŒåˆ†
```

## åŒºé—´åˆå¹¶

1. æŒ‰åŒºé—´å·¦ç«¯ç‚¹æ’åº
2. æŠŠæœ‰äº¤é›†çš„åŒºé—´åˆå¹¶â€”â€”ç»´æŠ¤ä¸€ä¸ªå½“å‰çš„åŒºé—´ï¼Œä¸‹ä¸ªåŒºé—´ä¸å…¶å…³ç³»æ˜¯ ...

```java
// å°†æ‰€æœ‰å­˜åœ¨äº¤é›†çš„åŒºé—´åˆå¹¶ï¼Œä¸¤ä¸ªåŒºé—´åªæœ‰ç«¯ç‚¹ç›¸åŒæ—¶ï¼Œä¹Ÿå¯ä»¥åˆå¹¶
// å¦‚æœåªç”¨è¾“å‡ºåˆå¹¶ååŒºé—´çš„ä¸ªæ•°ï¼Œå…¶å®å¯ä»¥å¤§å¤§ç®€åŒ–ä»£ç 
int[][] merge(int[][] a) {  
   if (a == null || a.length == 0 || a[0].length == 0) {  
      return new int[0][2];  
   }  
   Arrays.sort(a, Comparator.comparingInt(item -> item[0]));  
   List<int[]> res = new ArrayList<>();  
   for (int[] arr : a) {  
      int left = arr[0];  
      int right = arr[1];  
      int cur = res.size() - 1;	// resä¸­å¾…æ¯”è¾ƒçš„å½“å‰åŒºé—´çš„ä¸‹æ ‡
      if (res.size() == 0 || res.get(cur)[1] < left) {  
         res.add(new int[]{left, right});  
      } else {  
         int newRight = Math.max(res.get(cur)[1], right);  
         res.set(cur, new int[]{res.get(cur)[0], newRight});  
      }  
   }  
   return res.toArray(new int[res.size()][2]);  
}
```

# æ•°æ®ç»“æ„

## é“¾è¡¨ä¸é‚»æ¥è¡¨

### é“¾è¡¨

ä½¿ç”¨ç»“æ„ä½“åŠ æŒ‡é’ˆçš„æ–¹å¼å®ç°é“¾è¡¨éå¸¸æ…¢ï¼Œæ‰€ä»¥ç¬”è¯•é¢˜ä¸€èˆ¬ä¸ç”¨ï¼Œä¸»è¦é¢è¯•ç”¨ï¼Œè¿™é‡Œä½¿ç”¨æ•°ç»„æ¨¡æ‹Ÿé“¾è¡¨çš„æ–¹å¼ã€‚

#### æ•°ç»„æ¨¡æ‹Ÿå•é“¾è¡¨

å•é“¾è¡¨åœ¨ç®—æ³•é¢˜ã€ç¬”è¯•é‡Œç”¨çš„æœ€å¤šçš„æ˜¯é‚»æ¥è¡¨ï¼Œé‚»æ¥è¡¨æœ€å¸¸è§çš„åº”ç”¨å°±æ˜¯ï¼šå­˜å‚¨å›¾å’Œæ ‘ã€‚

```java
// headå­˜å‚¨å¤´æŒ‡é’ˆï¼Œe[]å­˜å‚¨èŠ‚ç‚¹çš„å€¼ï¼Œne[]å­˜å‚¨èŠ‚ç‚¹çš„nextæŒ‡é’ˆï¼Œidxè¡¨ç¤ºå½“å‰ç”¨åˆ°äº†å“ªä¸ªèŠ‚ç‚¹
int head, e[N], ne[N], idx;

// åˆå§‹åŒ–
void init() {
    // ä¸‹æ ‡0ä¸å­˜ä¸œè¥¿
    head = 0;
    idx = 1;
}

// åœ¨é“¾è¡¨å¤´æ’å…¥ä¸€ä¸ªæ•°x
void addHead(int x) {
    // å…ˆè®°å½• idx çš„å€¼
    // ç„¶åè®© idx æŒ‡å‘å¤´æŒ‡é’ˆæŒ‡å‘çš„ç»“ç‚¹
    // ä¿®æ”¹sæŒ‡é’ˆçš„æŒ‡å‘ä¸º idx
    // idx åŠ  1
    e[idx] = x;
    ne[idx] = head;
    head = idx ++;
}
// å°†xæ’å…¥åˆ°ä¸‹æ ‡kèŠ‚ç‚¹åé¢s
void add(int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx ++;
}

//å°†ä¸‹æ ‡kåé¢çš„ç‚¹åˆ æ‰
void remove(int k){
    // ç¬¬ k ä¸ªç»“ç‚¹æŒ‡å‘ next çš„ next
    else ne[k] = ne[ne[k]];
}
```

#### æ•°ç»„æ¨¡æ‹ŸåŒé“¾è¡¨

åŒé“¾è¡¨ä¸»è¦æ˜¯ç”¨æ¥ä¼˜åŒ–æŸäº›é—®é¢˜

```java
// e[]è¡¨ç¤ºèŠ‚ç‚¹çš„å€¼ï¼Œl[]è¡¨ç¤ºèŠ‚ç‚¹çš„å·¦æŒ‡é’ˆï¼Œr[]è¡¨ç¤ºèŠ‚ç‚¹çš„å³æŒ‡é’ˆï¼Œidxè¡¨ç¤ºå½“å‰ç”¨åˆ°äº†å“ªä¸ªèŠ‚ç‚¹
// ä¸è®¾ç½® head å’Œ tail ï¼Œè®¾ç½® 0 å’Œ 1 ä¸º head å’Œ tail
int e[N], l[N], r[N], idx;

// åˆå§‹åŒ–
void init() {
    //headæ˜¯å·¦ç«¯ç‚¹ï¼Œtailæ˜¯å³ç«¯ç‚¹ï¼Œæœ€åéƒ½ä¼šæ’åœ¨ä¸¤è€…ä¹‹é—´
    int head = 0, tail = N - 1;
    r[head] = tail, l[tail] = head;
    idx = 1;
}

// åœ¨èŠ‚ç‚¹kçš„å³è¾¹æ’å…¥ä¸€ä¸ªæ•°x
void insert(int k, int x) {
    e[idx] = x;
    l[idx] = k, r[idx] = r[k];
    l[r[k]] = idx, r[k] = idx ++ ;
}

// åœ¨kçš„å³è¾¹æ’å…¥x
insert(l[k], x)

// åˆ é™¤èŠ‚ç‚¹k
void remove(int k) {
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}

```

## æ ˆä¸é˜Ÿåˆ—

### æ ˆ

#### æ™®é€šæ ˆ

```java
// ttè¡¨ç¤ºæ ˆé¡¶
int stk[N], tt = 0;

// å‘æ ˆé¡¶æ’å…¥ä¸€ä¸ªæ•°
stk[ ++ tt] = x;

// ä»æ ˆé¡¶å¼¹å‡ºä¸€ä¸ªæ•°
tt -- ;

// æ ˆé¡¶çš„å€¼
stk[tt];

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
if (tt > 0)
```

#### å•è°ƒæ ˆ

**å¸¸ç”¨é¢˜å‹**ï¼šåœ¨åºåˆ—ä¸­æ¯ä¸€ä¸ªæ•°çš„å·¦/å³è¾¹ç¦»ä»–æœ€è¿‘çš„æ¯”å®ƒå°/å¤§çš„æ•°å­—åœ¨ä»€ä¹ˆåœ°æ–¹ã€‚

```java
int tt = 0;
for (int i = 1; i <= n; i ++ ) {
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

### é˜Ÿåˆ—

#### æ™®é€šé˜Ÿåˆ—

```java
// hh è¡¨ç¤ºé˜Ÿå¤´ï¼Œttè¡¨ç¤ºé˜Ÿå°¾
int q[N], hh = 0, tt = -1;

// å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªæ•°
q[ ++ tt] = x;

// ä»é˜Ÿå¤´å¼¹å‡ºä¸€ä¸ªæ•°
hh ++ ;

// é˜Ÿå¤´çš„å€¼
q[hh];

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
if (hh > tt)
```

#### å•è°ƒé˜Ÿåˆ—

```java
// å¸¸è§æ¨¡å‹ï¼šæ‰¾å‡ºæ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼/æœ€å°å€¼
int hh = 0, tt = -1;
// æ•°ç»„ q ä¿å­˜æ»‘åŠ¨çª—å£å¤„ç†åçš„ä¸¥æ ¼å•è°ƒé˜Ÿåˆ—å…ƒç´ çš„ä¸‹æ ‡
int[] q;
for (int i = 0; i < n; i ++ ) {
    // åˆ¤æ–­é˜Ÿå¤´æ˜¯å¦éœ€è¦æ»‘å‡ºçª—å£
    // é˜Ÿåˆ—ä¸ç©ºä¸”æ»¡è¶³å¼¹å‡ºæ¡ä»¶
    if (hh <= tt && check_out(q[hh])) hh ++ ; 
    // åˆ¤æ–­é˜Ÿå°¾å…ƒç´ æ˜¯å¦éœ€è¦å¼¹å‡º
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

## KMP

```java
// s[n]æ˜¯é•¿æ–‡æœ¬ï¼Œp[m]æ˜¯æ¨¡å¼ä¸²
// æ±‚æ¨¡å¼ä¸²çš„Nextæ•°ç»„ï¼Œä»1å¼€å§‹ï¼š
for (int i = 2, j = 0; i <= m; i ++ ) {
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// åŒ¹é…
for (int i = 1, j = 0; i <= n; i ++ ) {
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m) {
        // å†æ¬¡åŒ¹é…
        j = ne[j];
        // åŒ¹é…æˆåŠŸåçš„é€»è¾‘
    }
}
```

## Tire å­—å…¸æ ‘

Tire æ ‘ï¼šé«˜æ•ˆå­˜å‚¨å’ŒæŸ¥æ‰¾å­—ç¬¦ä¸²é›†åˆçš„æ•°æ®ç»“æ„

```java
int son[N][26], cnt[N], idx;
// 0å·ç‚¹æ—¢æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåˆæ˜¯ç©ºèŠ‚ç‚¹
// son[][]å­˜å‚¨æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œç›¸å½“äºé“¾è¡¨ä¸­çš„ne[]
// cnt[]å­˜å‚¨ä»¥æ¯ä¸ªèŠ‚ç‚¹ç»“å°¾çš„å•è¯æ•°é‡
// idx å¯ä»¥ç†è§£ä¸ºä¸åŒçš„ç»“ç‚¹

void insert(String s) {  
   // æŒ‡é’ˆï¼Œä»æ ¹èŠ‚ç‚¹åˆ°å°¾èŠ‚ç‚¹ï¼Œè·Ÿéšoçš„éå†è€Œå˜åŒ–
   int p = 0;  
   for (int i = 0; i < s.length(); i++) {  
      // uæ˜¯å­—ç¬¦çš„intå€¼  
      int u = s.charAt(i) - 'a';  
      // å¦‚æœåŒ¹é…ä¸åˆ°ï¼Œåˆ™åˆ›å»ºè¯¥èŠ‚ç‚¹
      if (son[p][u] == 0) son[p][u] = ++idx;  
      // æ›´æ–°ç»“ç‚¹
      p = son[p][u];  
   }  
   cnt[p]++;  
}

int query(String s) {  
   int p = 0;  
   for (int i = 0; i < s.length(); i++) {  
      int u = s.charAt(i) - 'a';  
      if (son[p][u] == 0) return 0;
      p = son[p][u];  
   }
   return cnt[p];  
}
```

## å¹¶æŸ¥é›†

å¹¶æŸ¥é›†å¯ä»¥åœ¨è¿‘ä¹ O(1) çš„æ—¶é—´å†…å®Œæˆä»¥ä¸‹ä¸¤ä¸ªæ“ä½œ

1. å°†ä¸¤ä¸ªé›†åˆåˆå¹¶
2. æŸ¥è¯¢ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨ä¸€ä¸ªé›†åˆå½“ä¸­

**åŸºæœ¬åŸç†**ï¼šæ¯ä¸ªé›†åˆç”¨ä¸€æ£µæ ‘æ¥è¡¨ç¤ºï¼Œæ ‘æ ¹çš„ç¼–å·å°±æ˜¯æ•´ä¸ªé›†åˆçš„ç¼–å·ï¼Œæ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å®ƒçš„çˆ¶èŠ‚ç‚¹ï¼Œp[x] è¡¨ç¤º x çš„çˆ¶èŠ‚ç‚¹ã€‚

- é—®é¢˜ä¸€ï¼šå¦‚ä½•åˆ¤æ–­æ ‘æ ¹ï¼šif(p[x] == x)ï¼Œé™¤äº†æ ¹èŠ‚ç‚¹ä¹‹å¤–ï¼Œp[x] éƒ½ä¸ç­‰äº xï¼›
- é—®é¢˜äºŒï¼šå¦‚ä½•æ±‚ x çš„é›†åˆç¼–å·ï¼ˆæ ‘æ ¹ï¼‰ï¼šwhile(p[x] != x) x = p[x]ï¼›
- é—®é¢˜ä¸‰ï¼šå¦‚ä½•åˆå¹¶ä¸¤ä¸ªé›†åˆï¼šp[x] æ˜¯ x çš„é›†åˆç¼–å·ï¼Œp[y] æ˜¯ y çš„é›†åˆç¼–å·ï¼Œp[x] = yã€‚
- ä¼˜åŒ–ï¼š
	- è·¯å¾„å‹ç¼©ï¼šä¸€ä¸ªèŠ‚ç‚¹æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œå°±æŠŠè·¯å¾„ä¸Šç»è¿‡çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼›
	- æŒ‰è´¨åˆå¹¶ï¼šä¸€èˆ¬å¾ˆå°‘ç”¨ã€‚

```java
(1)æœ´ç´ å¹¶æŸ¥é›†ï¼š

    int p[N]; //å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹
    // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
    int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;
    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
    p[find(a)] = find(b);

(2)ç»´æŠ¤sizeçš„å¹¶æŸ¥é›†ï¼š

    //size[]åªæœ‰ç¥–å®—èŠ‚ç‚¹çš„æœ‰æ„ä¹‰ï¼Œè¡¨ç¤ºç¥–å®—èŠ‚ç‚¹æ‰€åœ¨é›†åˆä¸­çš„ç‚¹çš„æ•°é‡
    int p[N], size[N];

    int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    
    for (int i = 1; i <= n; i ++ ) {
        p[i] = i;
        size[i] = 1;
    }
    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼Œä¸‹é¢ä¸¤å¥ä¸€å®šä¸èƒ½é¢ å€’ï¼š
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);

(3)ç»´æŠ¤åˆ°ç¥–å®—èŠ‚ç‚¹è·ç¦»çš„å¹¶æŸ¥é›†ï¼š
    
    // d[x]å­˜å‚¨xåˆ°p[x]çš„è·ç¦»
    int p[N], d[N];

    // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
    int find(int x){
        if (p[x] != x){
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    for (int i = 1; i <= n; i ++ ){
        p[i] = i;
        d[i] = 0;
    }
    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
    p[find(a)] = find(b);
    d[find(a)] = distance; // æ ¹æ®å…·ä½“é—®é¢˜ï¼Œåˆå§‹åŒ–find(a)çš„åç§»é‡
```

## å †

å †çš„**å­˜å‚¨**ï¼ˆå®Œå…¨äºŒå‰æ ‘ï¼‰ï¼š
æŒ‰ç…§å°æ ¹å †ï¼ˆæœ€å°å †ï¼‰æ¥å­˜å‚¨ï¼›ä½¿ç”¨ä¸€ç»´æ•°ç»„å­˜å‚¨ï¼Œä¸‹æ ‡ä» 1 å¼€å§‹ï¼Œè‹¥çˆ¶èŠ‚ç‚¹ä¸º x ï¼Œåˆ™å·¦å„¿å­ä¸º 2xï¼Œå³å„¿å­ä¸º 2x+1ã€‚

**ä¸¤ä¸ªåŸºæœ¬æ“ä½œ**ï¼š
down(x)ï¼šå°†ä¸€ä¸ªèŠ‚ç‚¹å‘ä¸‹ç§»ï¼›å®ç°é€»è¾‘ï¼šä¸è¾ƒå°çš„å„¿å­äº¤æ¢
up(x)ï¼šå°†ä¸€ä¸ªèŠ‚ç‚¹å‘ä¸Šç§»ï¼›å®ç°é€»è¾‘ï¼šä¸çˆ¶èŠ‚ç‚¹æ¯”è¾ƒï¼Œè‹¥å°äºçˆ¶èŠ‚ç‚¹åˆ™äº¤æ¢

åœ¨å°†ä¸€ä¸ª**æ•°ç»„å»ºå †**çš„æ—¶å€™ï¼Œè‹¥ä¸€ä¸ªä¸ªæ’å…¥å †ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(nlogn)ï¼Œè€Œä½¿ç”¨ for (int i= n /2; i; i-- ) down(i)ï¼›å¯å®ç° O(n) å»ºå †ï¼Œå› ä¸ºæœ€ä¸‹é¢ä¸€æ’å¶èŠ‚ç‚¹ä¸ç”¨å‚ä¸ã€‚

```java
// h[N]å­˜å‚¨å †ä¸­çš„å€¼, h[1]æ˜¯å †é¡¶ï¼Œxçš„å·¦å„¿å­æ˜¯2x, å³å„¿å­æ˜¯2x + 1
// ph[k]å­˜å‚¨ç¬¬ k ä¸ªæ’å…¥çš„ç‚¹åœ¨å †ä¸­çš„ä½ç½®
// hp[m]å­˜å‚¨å †ä¸­ä¸‹æ ‡æ˜¯ m çš„ç‚¹æ˜¯ç¬¬å‡ ä¸ªæ’å…¥çš„
int h[N], ph[N], hp[N], size;

// äº¤æ¢ä¸¤ä¸ªç‚¹ï¼ŒåŠå…¶æ˜ å°„å…³ç³»ï¼Œä¸€èˆ¬çš„å †ä¸éœ€è¦ç»´æŠ¤å¤æ‚çš„æ˜ å°„å…³ç³»
void heap_swap(int a, int b) {
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}
// è¿›è¡Œdownæ“ä½œæ—¶å¿…é¡»æ»¡è¶³å·¦å„¿å­å’Œå³å„¿å­å·²ç»æ˜¯å †
void down(int u) {
    // ä¸‰ä¸ªç‚¹ä¸­çš„æœ€å°å€¼
    int t = u;
    // å¦‚æœå·¦å­èŠ‚ç‚¹åˆæ³•ï¼Œå¹¶ä¸”å·¦å­èŠ‚ç‚¹å°äºå½“å‰èŠ‚ç‚¹ï¼Œåˆ™éœ€è¦è°ƒæ•´å †
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    // åŒç†
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    // å¦‚æœéœ€è¦è°ƒæ•´
    if (u != t) {
        heap_swap(u, t);
        // é€’å½’
        down(t);
    }
}

void up(int u) {
    // çˆ¶èŠ‚ç‚¹åˆæ³•ï¼Œå¹¶ä¸”çˆ¶èŠ‚ç‚¹å¤§äºå½“å‰èŠ‚ç‚¹
    while (u / 2 > 0 && h[u] < h[u / 2]) {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)å»ºå †
for (int i = n / 2; i > 0; i -- ) down(i);
```

å®ç°äº”ä¸ªåŸºæœ¬ä½¿ç”¨æ“ä½œï¼š

1. æ’å…¥ä¸€ä¸ªæ•°ï¼š`heap[++size] = x; up(size);`
2. æ±‚é›†åˆå½“ä¸­çš„æœ€å°å€¼ï¼š`heap[1];`
3. åˆ é™¤æœ€å°å€¼ï¼š`heap[1] = heap[size]; size--; down(1);`ï¼ˆæœ€åä¸€ä¸ªå…ƒç´ è¦†ç›–å †é¡¶å…ƒç´ ï¼‰
4. åˆ é™¤ä»»æ„ä¸€ä¸ªå…ƒç´ ï¼š`heap[k] = heap[size]; size--; down(k); up(k);`ï¼ˆåŒç†ï¼‰
5. ä¿®æ”¹ä»»æ„ä¸€ä¸ªå…ƒç´ ï¼š`heap[k] = x; down(k); up(k);`

é™¤äº† 2 æ˜¯ O(1) çš„ï¼Œå…¶ä»–æ˜¯ O(logn) çš„ã€‚

## å“ˆå¸Œè¡¨

### ä¸€èˆ¬å“ˆå¸Œ

å°†ä¸€ä¸ªå¾ˆå¤§çš„å€¼åŸŸæ˜ å°„åˆ° 0~N çš„ç©ºé—´ä¸Šï¼Œä¸€èˆ¬ N ä¸º $10^5$ æˆ– $10^6$ã€‚
ä¸€èˆ¬æ˜ å°„æ˜¯ä½¿ç”¨å–æ¨¡çš„æ–¹æ³•ï¼Œä¸” mod çš„æ•°ä¸€èˆ¬å–è´¨æ•°ï¼Œè¯¥è´¨æ•°ä¸€èˆ¬ç¦» 2 çš„æ•´æ¬¡å¹‚å°½å¯èƒ½çš„è¿œï¼Œå› ä¸ºè¿™æ ·å–çš„è¯ï¼Œå†²çªçš„å¯èƒ½æ€§æœ€å°ã€‚
è¿™é‡Œå– x mod å¤§äº $10^5$ çš„è´¨æ•°ï¼Œç¬¬ä¸€ä¸ªä¸º 100003ï¼Œä¸»è¦åŒºåˆ«åœ¨äºæ˜ å°„æ—¶çš„å†²çªå¦‚ä½•å¤„ç†ã€‚
ä¸€èˆ¬åªæœ‰æ·»åŠ å’ŒæŸ¥æ‰¾ä¸¤ä¸ªæ“ä½œï¼Œå¾ˆå°‘ä¼šæœ‰åˆ é™¤çš„æ“ä½œã€‚

**å­˜å‚¨ç»“æ„**

**æ‹‰é“¾æ³•**
å¼€ä¸€ä¸ªä¸€ç»´æ•°ç»„å­˜å‚¨æ‰€æœ‰çš„å€¼ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸€ä½å­˜å‚¨ e[ ] å’Œ ne[ ]ï¼Œå› ä¸ºæŠŠæ¯ä¸€ä½çœ‹ä½œä¸€ä¸ªæ§½ï¼Œé‡Œé¢æ”¾ä¸€ä¸ªé“¾è¡¨ï¼Œç†æƒ³çš„æƒ…å†µä¸‹æ¯ä¸ªæ§½åªæœ‰ä¸€ä¸ªæ•°ï¼Œå†²çªçš„æ—¶å€™ä¼šéœ€è¦é“¾è¡¨ã€‚
**æ·»åŠ **å’Œ**æŸ¥æ‰¾**ï¼šh(x)



**å¼€æ”¾å¯»å€æ³•**
åªå¼€äº†ä¸€ä¸ªä¸€ç»´æ•°ç»„æ²¡æœ‰å¼€é“¾è¡¨ï¼Œä¸€èˆ¬é•¿åº¦ä¸ºé¢˜ç›®æ•°æ®èŒƒå›´çš„ 2 ~ 3 å€ï¼ˆç»éªŒèŒƒå›´ï¼Œè¿™æ ·å‘ç”Ÿå†²çªçš„å¯èƒ½æ€§è¾ƒä½ï¼‰ã€‚
å¤„ç†å†²çªï¼šh(x) = kï¼Œè‹¥è¯¥ä½ç½®å·²æœ‰æ•°å€¼ï¼Œåˆ™åç§»ä¸€ä½ï¼Œç›´è‡³ç§»è‡³ä¸€ä¸ªç©ºä½å­˜å‚¨ã€‚

**æ·»åŠ **ï¼šh(x) = kï¼Œæœ‰æ•°å°±åç§»ï¼Œæ²¡æ•°å°±å­˜å‚¨ï¼Œè‹¥æœ‰ç›¸åŒæ•°åˆ™æ— éœ€æ“ä½œã€‚
**æŸ¥æ‰¾**ï¼šh(x) = kï¼Œå½“å‰ä½æœ‰æ•°åˆ¤æ–­æ˜¯å¦ä¸º x ï¼Œä¸æ˜¯å°±åç§»ï¼Œç›´è‡³æ‰¾åˆ°æˆ–è€…é‡åˆ°ç©ºä½ï¼Œé‡åˆ°ç©ºä½è¯´æ˜ä¸å­˜åœ¨ x 

```java
(1) æ‹‰é“¾æ³•
int h[N], e[N], ne[N], idx;

// å‘å“ˆå¸Œè¡¨ä¸­æ’å…¥ä¸€ä¸ªæ•°
void insert(int x) {
    // ç”±äºè´Ÿæ•°æ±‚æ¨¡ä¹Ÿæ˜¯è´Ÿæ•°ï¼Œå› æ­¤åŠ ä¸ŠN
    int k = (x % N + N) % N;
    // å¤´æ’æ³•
    e[idx] = x;
    ne[idx] = h[k];		// h[k]ç†è§£ä¸ºå¤´æŒ‡é’ˆ
    h[k] = idx++;
}
// åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥è¯¢æŸä¸ªæ•°æ˜¯å¦å­˜åœ¨
boolean find(int x) {
    int k = (x % N + N) % N;
    for (int i = h[k]; i != 0; i = ne[i])
        if (e[i] == x) return true;
    return false;
}

(2) å¼€æ”¾å¯»å€æ³•
int h[N];
Arrays.fill(h, INF);	// ä»£è¡¨æ­¤ä½ç½®æ²¡æœ‰è¢«ç”¨
// å¦‚æœxåœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›xçš„ä¸‹æ ‡ï¼›å¦‚æœxä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›xåº”è¯¥æ’å…¥çš„ä½ç½®
int find(int x) {
    int t = (x % N + N) % N;
    while (h[t] != INF && h[t] != x) {
        t ++ ;
        // å¾ªç¯ï¼Œæœ€åä¸€ä¸ªå‘ä½çœ‹å®Œäº†çœ‹ç¬¬ä¸€ä¸ª
        if (t == N) t = 0;
    }
    return t;
}
```

### å­—ç¬¦ä¸²å‰ç¼€å“ˆå¸Œ

ç®€å•è¯´å°±æ˜¯æŠŠä¸€ä¸ªå­—ç¬¦ä¸²æ˜ å°„æˆä¸€ä¸ªæ•°å­—
å…·ä½“ç‚¹ï¼Œå°±æ˜¯æŠŠä¸€ä¸ªå­—ç¬¦ä¸²å¦‚ â€ABCâ€ æ˜ å°„æˆä¸€ä¸ª p è¿›åˆ¶çš„æ•°å­—
$ABC â€“> p^2*A + p^1*B + p^0*C$ = å“ˆå¸Œå€¼

**æ±‚å“ˆå¸Œå€¼çš„æ–¹æ³•ï¼š**

1. å°†å­—ç¬¦ä¸²çœ‹ä½œæ˜¯ä¸€ä¸ª P è¿›åˆ¶çš„æ•°
2. å°†è¯¥ P è¿›åˆ¶çš„æ•°æ”¹ä¸º 10 è¿›åˆ¶æ•°
3. æ¨¡ Q æ¥å°†è¯¥æ•°å­—æ˜ å°„åˆ° 0 ~ Q - 1 çš„åŒºé—´

**æ³¨æ„ï¼š**

1. ä¸€èˆ¬**ä¸èƒ½æ˜ å°„æˆ 0** ã€‚ï¼ˆåŸå› ï¼šå¯èƒ½ä¼šå°†ä¸åŒçš„å­—ç¬¦ä¸²æ˜ å°„ä¸ºç›¸åŒçš„å€¼ã€‚å¦‚ï¼Œè‹¥ A ä¸º 0 ï¼Œæ˜ å°„åä¸º 0 ï¼›AA ä¹Ÿä¸º 0 ï¼Œæ˜ å°„ååŒæ ·æ˜¯ 0ï¼‰
2. ä¸€èˆ¬å– **P = 131 æˆ– 13331** ï¼Œ**Q = $2^{64}$**ï¼ŒåŸºæœ¬ä¸ä¼šå‡ºç°å†²çªã€‚

```java
// h[k]å­˜å‚¨å­—ç¬¦ä¸²å‰kä¸ªå­—æ¯çš„å“ˆå¸Œå€¼, p[k]å­˜å‚¨ P^k mod Qï¼Œjavaä¸­longæœ‰æº¢å‡ºæ“ä½œï¼Œæº¢å‡ºçš„ç»“æœå°±æ˜¯å–æ¨¡çš„ç»“æœ
long[] h[N], p[N]; 
char[] sc;		// å­—ç¬¦åŒ–
// åˆå§‹åŒ–
p[0] = 1;
for (int i = 1; i <= n; i ++ ) {
    h[i] = h[i - 1] * P + sc[i];
    p[i] = p[i - 1] * P;
}
// è®¡ç®—å­ä¸² sc[l ~ r] çš„å“ˆå¸Œå€¼
long get(int l, int r) {
    // å› ä¸ºå–æ¨¡è¿ç®—å¯¹åŠ å‡ä¹˜éƒ½æ˜¯åŒæ€çš„ï¼Œæ‰€ä»¥ç”¨å–æ¨¡åçš„ç»“æœæ¥è®¡ç®—ï¼Œå†å–æ¨¡å¾—åˆ°çš„ç»“æœä¹Ÿä¸€å®šæ˜¯æ­£ç¡®çš„
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

# æœç´¢ä¸å›¾è®º

## æ ‘ä¸å›¾çš„å­˜å‚¨

å­˜å‚¨æ–¹å¼ä¸¤ç§ï¼š

é‚»æ¥çŸ©é˜µï¼ˆç”¨çš„è¾ƒå°‘ï¼‰ ä¸èƒ½ä¿å­˜é‡è¾¹ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $n^2$ï¼Œè¾ƒé€‚åˆå­˜å‚¨ç¨ å¯†å›¾ã€‚
é‚»æ¥è¡¨ï¼ˆç”¨çš„å¤šï¼‰ åœ¨æ•°ç»„çš„æ¯ä¸ªèŠ‚ç‚¹ä¸Šéƒ½æœ‰ä¸€ä¸ªå•é“¾è¡¨ã€‚æ¯æ¬¡æ’å…¥ä¸€ä¸ªé“¾æ¥æ—¶ï¼Œåœ¨å•é“¾è¡¨å¤´éƒ¨æ’å…¥ï¼ˆå¤´æ’æ³•ï¼‰

```java
// å¯¹äºæ¯ä¸ªç‚¹kï¼Œå¼€ä¸€ä¸ªå•é“¾è¡¨ï¼Œå­˜å‚¨kæ‰€æœ‰é‚»æ¥ç‚¹ï¼›h[k]å­˜å‚¨è¿™ä¸ªå•é“¾è¡¨çš„å¤´æŒ‡é’ˆï¼ˆç±»ä¼¼æ‹‰é“¾è¡¨ï¼‰
int h[N], e[N], ne[N], idx;

// æ·»åŠ ä¸€æ¡è¾¹a->bï¼Œæ²¡æœ‰é¡ºåº
void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
```

## æ ‘ä¸å›¾çš„æœç´¢

DFS ä¼˜å…ˆæ·±åº¦ï¼Œåˆ°ä¸èƒ½å†å‰è¿›çš„æ—¶å€™ï¼ˆå¶å­èŠ‚ç‚¹ï¼‰å†å›æº¯ï¼›BFS ä¸€å±‚å±‚æœç´¢ï¼Œæœç´¢å®Œæ¯ä¸€ä»£èŠ‚ç‚¹åï¼Œå†æœç´¢ä¸‹ä¸€ä»£èŠ‚ç‚¹ã€‚

|          |       DFS       |   BFS    |
| :------: | :-------------: | :------: |
| æ•°æ®ç»“æ„ |      stack      |  queue   |
|   ç©ºé—´   | O(h)ï¼ˆhä¸ºæ·±åº¦ï¼‰ | $O(2^h)$ |

DFS åœ¨ç©ºé—´ä½¿ç”¨ä¸Šæœ‰ä¼˜åŠ¿ï¼Œä½†ä¸å…·æœ‰**æœ€çŸ­è·¯**æ€§ã€‚
BFS æœ‰ä¸€ä¸ª**æœ€çŸ­è·¯**çš„æ¦‚å¿µï¼Œå³å‡è®¾æ ‘ä¸­æ¯æ¡è¾¹çš„æƒé‡å‡ä¸º1ï¼Œ BFS æœç´¢åˆ°æŸä¸€ä¸ªç‚¹çš„è·¯å¾„ï¼Œä¸€å®šæ˜¯æœ€çŸ­è·ç¦»ã€‚

æœ€å°æ­¥æ•°ã€æœ€çŸ­è·ç¦»ï¼Œæœ€å°‘æ“ä½œç­‰ï¼šBFS
ç®—æ³•æ€è·¯è¾ƒå¥‡æ€ªæˆ–è€…ç©ºé—´è¦æ±‚è¾ƒé«˜ï¼šDFS

### DFS

æœ€é‡è¦çš„è€ƒè™‘ç‚¹åœ¨äºï¼š**é¡ºåº**ï¼Œå†³å®šè¦ä»¥ä»€ä¹ˆæ ·çš„é¡ºåºæ¥éå†æ‰€æœ‰æ–¹æ¡ˆï¼›æ—¶é—´å¤æ‚åº¦ O(n+m)
å›æº¯æ—¶ä¸è¦å¿˜äº†**æ¢å¤ç°åœº**ï¼Œå³å›æº¯å‰æ˜¯ä»€ä¹ˆæ ·ï¼Œå›æº¯åè¿˜åº”æ—¶ä»€ä¹ˆæ ·ã€‚

```java
void dfs(int u) {
    state[u] = true;
    if(åˆ°è¾¾ç»ˆç‚¹çŠ¶æ€) return; 
    for (int i = h[u]; i != 0; i = ne[i]) {	// éå†å¯æ‰©å±•çš„è·¯å¾„
        int j = e[i];	// æ‰©å±•èŠ‚ç‚¹
        if (!state[j] && check()) {	// æ‰©å±•èŠ‚ç‚¹æ˜¯å¦åˆæ³•ï¼Œå‰ªæ
            ä¿®æ”¹ç°åœº;
            dfs(j);
            è¿˜åŸç°åœº;	// çœ‹æ˜¯å¦éœ€è¦
        }
    }
}
```

### BFS

```java
Queue<Integer> q;
state[1] = true;	// è¡¨ç¤º1å·ç‚¹å·²ç»è¢«éå†è¿‡
q.add(1);

while (!q.isEmpty()){
    int t = q.poll();

    for (int i = h[t]; i != 0; i = ne[i]) {	// é˜Ÿå¤´ï¼ˆå½“å‰èŠ‚ç‚¹ï¼‰å¯æ‰©å±•è·¯å¾„
        int j = e[i];	// æ‰©å±•èŠ‚ç‚¹
        if (check() && !state[j]) {		// æ˜¯å¦èƒ½èµ°ä»¥åŠæ˜¯å¦èµ°è¿‡
            state[j] = true;
            q.add(j);
        }
    }
}
```

#### æ‹“æ‰‘æ’åº

é’ˆå¯¹æœ‰å‘å›¾ï¼Œæ— å‘å›¾æ²¡æœ‰æ‹“æ‰‘åºåˆ—ã€‚**å®šä¹‰**ï¼šè‹¥ä¸€ä¸ªç”±å›¾ä¸­æ‰€æœ‰ç‚¹æ„æˆçš„åºåˆ— A æ»¡è¶³ï¼šå¯¹äºå›¾ä¸­çš„æ¯æ¡è¾¹ (x, y)ï¼Œx åœ¨ A ä¸­éƒ½å‡ºç°åœ¨ y ä¹‹å‰ï¼Œåˆ™ç§° A æ˜¯è¯¥å›¾çš„ä¸€ä¸ª**æ‹“æ‰‘åºåˆ—**ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n+m)$

```java
boolean topsort() {
    int hh = 0, tt = -1;

    // d[i] å­˜å‚¨ç‚¹içš„å…¥åº¦
    for (int i = 1; i <= n; i ++ )
        // åˆå§‹åŒ–ï¼Œå…¥åº¦ä¸º0çš„å…¥é˜Ÿåˆ—
        if (d[i] == 0) q[++tt] = i;

    while (hh <= tt) {
        int t = q[hh++];
        for (int i = h[t]; i != 0; i = ne[i]) {
            int j = e[i];
            if (--d[j] == 0) q[++tt] = j;
        }
    }
    // å¦‚æœæ‰€æœ‰ç‚¹éƒ½å…¥é˜Ÿäº†ï¼Œè¯´æ˜å­˜åœ¨æ‹“æ‰‘åºåˆ—ï¼›å¦åˆ™ä¸å­˜åœ¨æ‹“æ‰‘åºåˆ—ã€‚
    return tt == n - 1;
}
```

## æœ€çŸ­è·¯

æœ€çŸ­è·¯é—®é¢˜åˆ†ä¸ºå•æºæœ€çŸ­è·¯å’Œå¤šæºæ±‡æœ€çŸ­è·¯ï¼Œè€ƒå¯Ÿçš„ä¾§é‡ç‚¹åœ¨äºä»èƒŒæ™¯æŠ½è±¡å»ºå›¾ï¼Œä¸åœ¨äºç®—æ³•çš„è¯æ˜ã€‚

**ä¸€èˆ¬ç”¨ SPFA ç®—æ³•**

```mermaid
graph LR
æœ€çŸ­è·¯é—®é¢˜--> A1(å•æºæœ€çŸ­è·¯)
A1-->B1(æ‰€æœ‰è¾¹çš„æƒéƒ½æ˜¯æ­£æ•°)
B1-->æœ´ç´ Dijkstraç®—æ³•:ç¨ å¯†å›¾,å¤æ‚åº¦næ–¹
B1-->å †ä¼˜åŒ–ç‰ˆDijkstraç®—æ³•:ç¨€ç–å›¾,å¤æ‚åº¦mlogn
A1-->B2(å­˜åœ¨è´Ÿæƒè¾¹)
B2-->Bellman-Ford:å¤æ‚åº¦nm
B2-->SPFA:è¦æ±‚ä¸å­˜åœ¨è´Ÿç¯,å¤æ‚åº¦ä¸€èˆ¬mæœ€ånm
æœ€çŸ­è·¯é—®é¢˜--> A2(å¤šæºæ±‡æœ€çŸ­è·¯)
A2-->Floydç®—æ³•:å¤æ‚åº¦nä¸‰æ–¹
```

### æœ´ç´  dijkstra

æ—¶é—´å¤æ‚åº¦ $O(n^2+m)$

```java
åˆå§‹åŒ– dist[1] = 0, dist[i] = æ­£æ— ç©·
for n æ¬¡
    for éå†æ¯ä¸€ä¸ªç‚¹
        æ‰¾åˆ°æœªå¤„ç†çš„è·ç¦»èµ·ç‚¹çš„æœ€å°å€¼ t
	ç”¨ t æ›´æ–°æ‰€æœ‰ dist[i]
```

```java
int g[N][N];  // é‚»æ¥çŸ©é˜µ
int dist[N];  // å­˜å‚¨èµ·å§‹ç‚¹åˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»
boolean st[N];   // å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·¯æ˜¯å¦å·²ç»ç¡®å®š

int dijkstra() {
    Arrays.fill(dist, INF);
    dist[1] = 0;
    // æ¯æ¬¡å¿…ç„¶å¯ä»¥ç¡®å®šä¸€ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»
    for (int i = 0; i < n; i ++ ) {
        int t = -1;     // åˆå§‹ç‚¹
        // åœ¨è¿˜æœªç¡®å®šæœ€çŸ­è·¯çš„ç‚¹ä¸­ï¼Œå¯»æ‰¾distæœ€å°çš„ç‚¹
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // ç”¨tæ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }
    if (dist[n] == INF) return -1;
    return dist[n];
}
```

### å †ä¼˜åŒ– dijkstra

æ—¶é—´å¤æ‚åº¦ $O(mlogn)$

```java
int h[N], w[N], e[N], ne[N], idx;       // é‚»æ¥è¡¨
int dist[N];        
boolean st[N];

int dijkstra() {
    Arrays.fill(dist, INF);
    dist[1] = 0;
    PriorityQueue<int[]> heap;		// [èŠ‚ç‚¹ç¼–å·,è·ç¦»]
    heap.offer(new int[]{0, 1});

    while (!heap.isEmpty()) {
        int[] a = heap.poll();
        int t = a[0], distance = a[1];

        if (st[t]) continue;
        st[t] = true;
		
        for (int i = h[t]; i != 0; i = ne[i]) {
            int j = e[i];
            if (dist[j] > distance + w[i]) {
                dist[j] = distance + w[i];
                heap.offer(new int[]{j, dist[j]});
            }
        }
    }
    if (dist[n] == INF) return -1;
    return dist[n];
}
```

æ—¶é—´å¤æ‚åº¦ $O(mn)$

### Bellman-Ford ç®—æ³•â€”â€”æœ‰è¾¹æ•°é™åˆ¶çš„æœ€çŸ­è·¯

```java
for n æ¬¡		// è¿­ä»£kæ¬¡çš„æ„ä¹‰æ˜¯ç»ä¸è¶…è¿‡kæ¡è¾¹åˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»
    		//æ‰€ä»¥å¦‚æœç¬¬næ¬¡è¿­ä»£ä»ç„¶ä¼šæ›´æ–°ï¼Œå°±è¯´æ˜å­˜åœ¨ä¸€æ¡é•¿åº¦æ˜¯n+1çš„æœ€çŸ­è·¯å¾„ï¼Œè¯´æ˜å›¾ä¸­å­˜åœ¨è´Ÿæƒå›è·¯
    for æ‰€æœ‰è¾¹ a,b,w	// è¾¹ï¼Œaè¡¨ç¤ºå‡ºç‚¹ï¼Œbè¡¨ç¤ºå…¥ç‚¹ï¼Œwè¡¨ç¤ºæƒé‡
        dist[b] = min(dist[b], dist[a] + w)	// å¯¹äºæœ‰è¾¹æ•°é™åˆ¶çš„é—®é¢˜éœ€è¦ç”¨distçš„å¤‡ä»½æ•°ç»„back[a]
```

```java
int n, m;       // nè¡¨ç¤ºç‚¹æ•°ï¼Œmè¡¨ç¤ºè¾¹æ•°
int dist[N];        // dist[x]å­˜å‚¨1åˆ°xçš„æœ€çŸ­è·¯è·ç¦»

class Edge {
    int a, b, w;
    public Edge(int a, int b, int w) {
        this.a = a; this.b = b; this.w = w;
    }
}
edges[Edge];

int bellman_ford() {
    Arrays.fill(dist, INF);
    dist[1] = 0;

    for (int i = 0; i < n; i ++ ) {
        for (int j = 0; j < m; j ++ ) {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            dist[b] = min(dist[a] + w, dist[b]);
        }
    }
    return dist[n];
}
if (dist[n] > INF / 2) sout("impossible");
```

### spfa ç®—æ³•ï¼ˆé˜Ÿåˆ—ä¼˜åŒ–çš„ Bellman-Ford ç®—æ³•ï¼‰

æ—¶é—´å¤æ‚åº¦ å¹³å‡æƒ…å†µä¸‹ $O(ğ‘š)$ï¼Œæœ€åæƒ…å†µä¸‹ $O(ğ‘›ğ‘š)$ ï¼Œspfa å°±æ˜¯ bellman-ford ç®—æ³•åŠ ä¸Š bfs ä¼˜åŒ–

```java
dist[b] = min(dist[b], dist[a] + w) å¯ä»¥å‘ç°åªæœ‰ dist[a] å˜å°äº†ï¼Œdist[b] æ‰ä¼šå˜å°
q.offer(1);		// qä¸­å­˜distå˜å°çš„èŠ‚ç‚¹
while(qä¸ç©º)
    t = q.pop();
    æ›´æ–° t çš„æ‰€æœ‰å‡ºè¾¹ï¼ŒæŠŠå‡ºè¾¹æŒ‡å‘çš„é¡¶ç‚¹å…¥é˜Ÿ
```

```java
int spfa() {
    Arrays.fill(dist, INF);
    dist[1] = 0;

    Queue<int> q;
    q.offer(1);
    st[1] = true;

    while (!q.isEmpty()) {
        int t = q.poll();
        st[t] = false;

        for (int i = h[t]; i != 0; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                if (!st[j]) {    // å¦‚æœé˜Ÿåˆ—ä¸­å·²å­˜åœ¨jï¼Œåˆ™ä¸éœ€è¦é‡å¤æ’å…¥
                    q.offer(j);
                    st[j] = true;
                }
            }
        }
    }
    return dist[n];
}
```

#### spfa åˆ¤æ–­å›¾ä¸­æ˜¯å¦å­˜åœ¨è´Ÿç¯

å¦å¤–ç»´æŠ¤ä¸€ä¸ª cnt[x] å­˜å‚¨ 1 åˆ° x çš„æœ€çŸ­è·¯ä¸­ç»è¿‡çš„è¾¹æ•°ï¼Œè‹¥ cnt[x] >= nï¼Œåˆ™å­˜åœ¨è´Ÿç¯

```java
// ä¸éœ€è¦åˆå§‹åŒ–distæ•°ç»„
// å› ä¸ºä»1å·ç‚¹ä¸ä¸€å®šèƒ½åˆ°è¾¾è´Ÿç¯ï¼Œæ‰€ä»¥ä¸€å¼€å§‹å°±æŠŠæ‰€æœ‰ç‚¹æ‰”è¿›é˜Ÿåˆ—
Queue<int> q;
for (int i = 1; i <= n; i ++ ) {
    q.offer(i);
    st[i] = true;
}
```

### Floyd ç®—æ³•

æœ¬è´¨æ˜¯åŠ¨æ€è§„åˆ’ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n^3)$

d[k, i, j] è¡¨ç¤º â€œ**ä¸­é—´**ï¼ˆä¸åŒ…æ‹¬ç«¯ç‚¹ï¼‰ç»è¿‡è‹¥å¹²ä¸ªç¼–å·ä¸è¶…è¿‡ k çš„èŠ‚ç‚¹â€ ä» i åˆ° j çš„æœ€çŸ­è·ç¦»ã€‚å¯ä»¥ä»ä¸¤ä¸ªçŠ¶æ€å¾—åˆ°ï¼š

1. ä¸ç»è¿‡ k ï¼šd[k - 1, i, j]
2. ç»è¿‡ k ä» i åˆ° jï¼šd[k - 1, i, k] + d[k - 1, k, j]ï¼ˆd[k - 1, i, k] = d[k, i, k]ï¼Œæ²¡æœ‰è´Ÿç¯æ—¶ï¼Œæœ€çŸ­è·¯ä¸å¯èƒ½ç»è¿‡é‡å¤ç‚¹ï¼‰

ä¹‹æ‰€ä»¥èƒ½é™åˆ°äºŒç»´ï¼Œæ˜¯å› ä¸ºåœ¨è¿™ä¸ªè½¬ç§»æ–¹ç¨‹çš„çº¦æŸä¸‹ï¼Œç¬¬ä¸€ä¸ªé¡¹è¯»å–çš„æ—¶å€™ä¸€å®šæ˜¯ä¸Šä¸€å±‚ï¼ˆk - 1ï¼‰çš„å€¼ï¼Œåä¸¤é¡¹ä¸Šä¸€å±‚å’Œå½“å‰å±‚çš„å€¼æ˜¯èƒ½å¤Ÿä¿è¯æ˜¯ä¸€æ ·çš„ã€‚

```java
int d[n][n]; 	// é‚»æ¥çŸ©é˜µ

// ç®—æ³•ç»“æŸåï¼Œd[a][b]è¡¨ç¤ºaåˆ°bçš„æœ€çŸ­è·ç¦»
void floyd() {
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

## æœ€å°ç”Ÿæˆæ ‘

### Prim ç®—æ³•

æ—¶é—´å¤æ‚åº¦ $O(n^2+m)$ï¼Œç”¨äºç¨ å¯†å›¾

æœ€å°ç”Ÿæˆæ ‘çš„è¾¹ï¼št å¯¹åº”é›†åˆçš„é‚£æ¡è¾¹

```java
dist[i] = INF;
for n æ¬¡
    æ‰¾åˆ°é›†åˆå¤–è·ç¦»æœ€è¿‘çš„ç‚¹ t		 // é›†åˆæŒ‡å½“å‰å·²ç»åœ¨æ ‘ä¸­çš„ç‚¹
    ç”¨ t æ›´æ–°å…¶ä»–ç‚¹åˆ°é›†åˆçš„è·ç¦»		// è·ç¦»å®šä¹‰ï¼šç‚¹åˆ°é›†åˆä¸­æ‰€æœ‰ç‚¹çš„è·ç¦»æœ€å°å€¼ã€‚
    st[t] = true
```

```java
// å¦‚æœå›¾ä¸è¿é€šï¼Œåˆ™è¿”å›INF, å¦åˆ™è¿”å›æœ€å°ç”Ÿæˆæ ‘çš„è¾¹æƒä¹‹å’Œ
int prim() {
    Arrays.fill(dist, INF);
    dist[1] = 0;

    int res = 0;
    // æ¯æ¬¡å¯ä»¥åŠ å…¥ä¸€ä¸ªç‚¹åˆ°æ ‘ä¸­
    for (int i = 0; i < n; i ++ ) {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (dist[t] == INF) return INF;
        res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) 
            dist[j] = min(dist[j], g[t][j]);	// æ³¨æ„æ­¤å¤„å’Œdijkstraçš„åŒºåˆ«
    }
    return res;
}
```

### Kruskal ç®—æ³•

æ—¶é—´å¤æ‚åº¦$O(mlonm)$ï¼Œç”¨äºç¨€ç–å›¾ï¼Œç”¨å¹¶æŸ¥é›†åš

```java
1. å°†æ‰€æœ‰è¾¹æŒ‰æƒé‡ä»å°åˆ°å¤§æ’åº
2. æšä¸¾æ¯æ¡è¾¹ abï¼Œc
    if a,b ä¸è¿é€š
        è¿æ¥ab
```

```java
class Edge {
    int a, b, w;
}

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal() {
    sort(edges);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // åˆå§‹åŒ–å¹¶æŸ¥é›†

    int res = 0, cnt = 0;	// cntå­˜å½“å‰æ ‘ä¸­çš„è¾¹æ•°
    for (int i = 0; i < m; i ++ ) {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b) {    // å¦‚æœä¸¤ä¸ªè¿é€šå—ä¸è¿é€šï¼Œåˆ™å°†è¿™ä¸¤ä¸ªè¿é€šå—åˆå¹¶
            p[a] = b;
            res += w;
            cnt ++ ;
        }
        if (cnt == n - 1) return res;
    }
    return INF;
}
```

## äºŒåˆ†å›¾

### æŸ“è‰²æ³•åˆ¤åˆ«

æ—¶é—´å¤æ‚åº¦$O(n+m)$

**äºŒåˆ†å›¾æ€§è´¨ï¼šå½“ä¸”ä»…å½“å›¾ä¸­ä¸å«å¥‡æ•°ç¯ã€‚**

åŸºäº DFS æŸ“è‰²ï¼Œå¦‚æœæŸ“è‰²å‡ºç°çŸ›ç›¾å°±ä¸æ˜¯äºŒåˆ†å›¾ï¼Œå¦åˆ™å°±æ˜¯äºŒåˆ†å›¾ã€‚

```java
int color[N];       // è¡¨ç¤ºæ¯ä¸ªç‚¹çš„é¢œè‰²ï¼Œ-1è¡¨ç¤ºæœªæŸ“è‰²ï¼Œ0è¡¨ç¤ºç™½è‰²ï¼Œ1è¡¨ç¤ºé»‘è‰²

// uè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œcè¡¨ç¤ºuçš„é¢œè‰²
boolean dfs(int u, int c) {
    color[u] = c;
    for (int i = h[u]; i != 0; i = ne[i]) {
        int j = e[i];
        // è¿˜æœªæŸ“è‰²
        if (color[j] == -1) {
            // é‚»æ¥ç‚¹æŸ“åè‰²åå‡ºç°çŸ›ç›¾
            if (!dfs(j, c^1)) return false;
        }
        // å·²æŸ“è‰²ï¼Œåˆ¤æ–­æ˜¯å¦çŸ›ç›¾
        else if (color[j] == c) return false;
    }
    return true;
}

boolean check() {
    Arrays.fill(color, -1);
    boolean flag = true;
    // å¯èƒ½æœ‰ä¸è¿é€šçš„æƒ…å†µï¼Œéœ€è¦éå†
    for (int i = 1; i <= n; i ++ )
        // å¦‚æœæ²¡æœ‰æŸ“è‰²ï¼Œé€’å½’æŸ“è‰²
        if (color[i] == -1)
            // å¦‚æœè¿”å›flaseï¼Œè¯´æ˜æŸ“è‰²å‡ºç°çŸ›ç›¾
            if (!dfs(i, 0)) {
                flag = false;
                break;
            }
    return flag;
}
```

### åŒˆç‰™åˆ©ç®—æ³•â€”â€”äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…

æ—¶é—´å¤æ‚åº¦$O(nm)$

```java
int n1, n2;     // ç”·ç”Ÿäººæ•°å’Œå¥³ç”Ÿäººæ•°
int h[N], e[M], ne[M], idx;     // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹ï¼ŒåŒˆç‰™åˆ©ç®—æ³•ä¸­åªä¼šç”¨åˆ°ä»ç¬¬ä¸€ä¸ªé›†åˆæŒ‡å‘ç¬¬äºŒä¸ªé›†åˆçš„è¾¹ï¼Œæ‰€ä»¥è¿™é‡Œåªç”¨å­˜ä¸€ä¸ªæ–¹å‘çš„è¾¹
int match[N];       // å­˜å‚¨å¥³ç”Ÿå½“å‰åŒ¹é…å“ªä¸ªç”·ç”Ÿ
boolean st[N];     // è¡¨ç¤ºæ¯ä¸ªå¥³ç”Ÿæ˜¯å¦å·²ç»è¢«éå†è¿‡

boolean find(int x) {
    // å°è¯•è¿½å„ä¸ªå¿ƒä»ªçš„å¯¹è±¡
    for (int i = h[x]; i != 0; i = ne[i]) {
        int j = e[i];
        if (!st[j]) {	// ä¸è¿½äºŒæ¬¡
            st[j] = true;
            // å¦¹å­è¿˜æ²¡å¯¹è±¡æˆ–è€…å¦¹å­çš„ç°ç”·å‹å¯ä»¥æ¢å¤‡èƒ
            if (match[j] == 0 || find(match[j])) {
                match[j] = x;	// èŠœæ¹–~åœ¨ä¸€èµ·
                return true;
            }
        }
    }
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ ) {
    // é‡ç½®stï¼ˆæœ‰å¯¹è±¡çš„å¥³ç”Ÿä¹Ÿå¯ä»¥è¢«è¿½ï¼‰
    Arrays.fill(st, false);
    if (find(i)) res ++ ;
}
```

# æ•°å­¦é—®é¢˜

## æ•°è®º

### è´¨æ•°

#### è¯•é™¤æ³•åˆ¤å®šè´¨æ•°

$O(sprt(n))$

```java
boolean is_prime(int x) {
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )	// i*i<=n
        if (x % i == 0)
            return false;
    return true;
}
```

#### è¯•é™¤æ³•åˆ†è§£è´¨å› æ•°

```java
void divide(int x) {
    for (int i = 2; i <= x / i; i++)
        if (x % i == 0) {	// iä¸€å®šæ˜¯è´¨æ•°
            int s = 0;	// içš„æ¬¡æ•°
            while (x % i == 0) x /= i, s++;
        }
    // n ä¸­æœ€å¤šåªåŒ…å«ä¸€ä¸ªå¤§äº sqrt(n) çš„è´¨å› å­
    // ç‰¹åˆ¤ï¼šå¦‚æœæœ€å x å¤§äº 1ï¼Œè¯´æ˜ x ä¸­å­˜åœ¨å¤§äº sqrt(n) çš„è´¨å› å­
    if(x > 1) sout(x + " " + 1);
}
```

#### æœ´ç´ ç­›æ³•æ±‚ç´ æ•°

æ¯ä¸ªæ•°è¢«è´¨æ•°ç­›æ‰ï¼Œæ—¶é—´å¤æ‚åº¦ O(nloglog(n))ï¼Œè¿‘ä¼¼ä¸º O(n)

**è´¨æ•°å®šç†ï¼š 1~n ä¸­æœ‰ n/log(n) ä¸ªè´¨æ•°**

```java
int primes[N], cnt;     // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•°
bool st[N];         // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰

void get_primes(int n) {
    for (int i = 2; i <= n; i ++ ) {
        if (!st[i]) {	// iæ˜¯ç´ æ•°
            primes[cnt ++ ] = i;
            // içš„å€æ•°æ˜¯åˆæ•°ï¼Œè¢«ç­›æ‰
        	for (int j = i; j <= n; j += i)
            	st[j] = true;
        }
    }
}
```

#### [#](https://www.acwing.com/solution/content/100707/)çº¿æ€§ç­›æ³•æ±‚ç´ æ•°

n åªä¼šè¢«**æœ€å°**è´¨å› å­ç­›æ‰

```java
void get_primes(int n) {
    for (int i = 2; i <= n; i ++ ) {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ ) {
            st[primes[j] * i] = true;	// ç”¨æœ€å°è´¨å› å­å»ç­›åˆæ•°
            if (i % primes[j] == 0) break;	// pjæ˜¯i*pjçš„æœ€å°è´¨å› å­ï¼Œé¿å…é‡å¤ç­›
        }
    }
}
```

### çº¦æ•°

#### è¯•é™¤æ³•æ±‚çº¦æ•°

```java
void getDivisor(int x) {
    List<Integer> res;
    for(int i = 1; i <= x / i; i++) {
        if(x % i == 0) {
            res.add(i);
            // æˆå¯¹å‡ºç°
            if(i != x / i) res.add(a / i);
        }
    }
}
```

#### çº¦æ•°ä¸ªæ•° / çº¦æ•°ä¹‹å’Œ

```
N = p1^c1 * p2^c2 * ... *pk^ck
çº¦æ•°ä¸ªæ•°ï¼š (c1 + 1) * (c2 + 1) * ... * (ck + 1)
çº¦æ•°ä¹‹å’Œï¼š (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
```

### æ¬§å‡ é‡Œå¾—ç®—æ³•

åŸç†ï¼š(a, b) = (b, a % b)

```java
int gcd(int a, int b) {
    return b > 0 ? gcd(b, a % b) : a;
}
```

#### æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•â€”â€”è£´å±å®šç†

```java
è®¾ax1+by1=gcd(a,b), bx2+(a%b)y2=gcd(b,a%b);
ç”±gcd(a,b)=gcd(b,a%b),å¯å¾—:
ax1+by1=bx2+(a%b)y2;
å³:ax1+by1=bx2+(a-(a/b)*b)y2
          =ay2+bx2-(a/b)*by2;
å³:ax1+by1=ay2 + b(x2-(a/b)*y2)
æ ¹æ®æ’ç­‰å®šç†,å¯¹åº”é¡¹ç›¸ç­‰ï¼Œå¾—:x1=y2; y1=x2-(a/b)*y2;
è¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†:x1ï¼Œy1çš„å€¼åŸºäºx2ï¼Œy2ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡é€’å½’æ±‚è§£ã€‚
```

```java
// æ±‚x, yï¼Œä½¿å¾—ax + by = gcd(a, b)
void exgcd(int a, int b, int x, int y) {
    if (b == 0) {
        x = 1; y = 0;
        return;
    }
    exgcd(b, a % b);
    int t = x;
    x = y;
    y = t - a / b * y;
}
```

#### ä¸­å›½å‰©ä½™å®šç†



### æ¬§æ‹‰å‡½æ•°

è¯æ˜ï¼šå®¹æ–¥åŸç†

```java
int phi(int x) {
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0) {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```

#### ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•°

```java
int primes[N], cnt;     // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•°
int euler[N];           // å­˜å‚¨æ¯ä¸ªæ•°çš„æ¬§æ‹‰å‡½æ•°
bool st[N];         // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰
void get_eulers(int n) {
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ ) {
        if (!st[i]) {
            primes[cnt ++ ] = i;
            // å¦‚æœä¸€ä¸ªæ•°æ˜¯è´¨æ•°çš„è¯ï¼Œé™¤äº†æœ¬èº«ï¼Œå…¶ä»–æ‰€æœ‰æ•°éƒ½å’Œå®ƒäº’è´¨ï¼Œæ‰€ä»¥ä¸ªæ•°å°±æ˜¯ i - 1
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ ) {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0) {
                // pjæ˜¯içš„è´¨å› å­ï¼Œè¯´æ˜içš„å…¬å¼é‡Œå·²ç»åŒ…å«äº†è¿™ä¸ªå› å­çš„è¡¨è¾¾
                // æ ¹æ®å…¬å¼ï¼Œåªéœ€è¦å†ä¹˜ä»¥ pj
                euler[t] = euler[i] * primes[j];
                break;
            }
            // å¦‚æœ pj ä¸æ˜¯ i çš„è´¨å› å­ï¼Œæ ¹æ®å…¬å¼å¦‚ä¸‹
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```

### å¿«é€Ÿå¹‚

å¯ä»¥å¿«é€Ÿæ±‚ $m^kmod p$ï¼Œæ—¶é—´å¤æ‚åº¦$O(logk)$

æ€è·¯ï¼šé¢„å¤„ç†å‡º  $m^{2^0},m^{2^1},m^{2^2},...,m^{2^logk}$ï¼Œå†å°† k è¡¨ç¤ºä¸ºäºŒè¿›åˆ¶

```java
int qmi(int m, int k, int p) {
    int res = 1;
    while (k != 0) {	// å¯¹kè¿›è¡ŒäºŒè¿›åˆ¶åŒ–,ä»ä½ä½åˆ°é«˜ä½
        if (k & 1 == 1) res = res * m % p;	// ä¹˜ä¸Šå½“å‰å¹‚æ¬¡çš„ç»“æœ
        m = m * m % p;	// è®¡ç®—m^{2^0},m^{2^1},m^{2^2},...
        k >>= 1;
    }
    return res;
}
```

## é«˜æ–¯æ¶ˆå…ƒ

æšä¸¾æ¯ä¸€åˆ—cï¼š

- æ‰¾åˆ°å½“å‰åˆ—ç»å¯¹å€¼æœ€å¤§çš„ä¸€è¡Œ
- ç”¨åˆç­‰è¡Œå˜æ¢(2) æŠŠè¿™ä¸€è¡Œæ¢åˆ°ä¸Šé¢ï¼ˆæœªç¡®å®šé˜¶æ¢¯å‹çš„è¡Œï¼Œå¹¶ä¸æ˜¯ç¬¬ä¸€è¡Œï¼‰
- ç”¨åˆç­‰è¡Œå˜æ¢(1) å°†è¯¥è¡Œçš„ç¬¬ä¸€ä¸ªæ•°å˜æˆ 1ï¼ˆå…¶ä½™æ‰€æœ‰çš„æ•°å­—ä¾æ¬¡è·Ÿç€å˜åŒ–ï¼‰
- ç”¨åˆç­‰è¡Œå˜æ¢(3) å°†ä¸‹é¢æ‰€æœ‰è¡Œçš„å½“ä¸”åˆ—çš„å€¼å˜æˆ 0

```java
int[] a[N][N]	// å¢å¹¿çŸ©é˜µ
int gauss() {
    int c, r;	// c=column,r=row
    for (c = 0, r = 0; c < n; c ++ ) {	// éå†æ¯åˆ—
        int t = r;
        for (int i = r; i < n; i ++ )   // æ‰¾åˆ°ç»å¯¹å€¼æœ€å¤§çš„è¡Œ
            if (abs(a[i][c]) > abs(a[t][c]))
                t = i;

        if (abs(a[t][c]) < eps) continue;	// æœ€å¤§å€¼ä¸º0

        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);    // å°†ç»å¯¹å€¼æœ€å¤§çš„è¡Œæ¢åˆ°é¡¶ç«¯
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // å°†å½“å‰è¡Œçš„é¦–ä½å˜æˆ1
        for (int i = r + 1; i < n; i ++ )       // ç”¨å½“å‰è¡Œå°†ä¸‹é¢æ‰€æœ‰çš„åˆ—æ¶ˆæˆ0
            if (abs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
        r ++ ;
    }
    if (r < n) {
        for (int i = r; i < n; i ++ )
            if (abs(a[i][n]) > eps)
                return 2; // æ— è§£
        return 1; // æœ‰æ— ç©·å¤šç»„è§£
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // æœ‰å”¯ä¸€è§£
}
```

## ç»„åˆè®¡æ•°

### é€’å½’æ³•æ±‚ç»„åˆæ•°ï¼ˆé¢„å¤„ç†ï¼‰

$O(n^2)$

```java
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (j == 0) c[i][j] = 1;
        else c[i][j] = c[i - 1][j] + c[i - 1][j - 1];
```

$O(NlogN)$

```java
// é€šè¿‡é¢„å¤„ç†é€†å…ƒçš„æ–¹å¼æ±‚ç»„åˆæ•°
// é¦–å…ˆé¢„å¤„ç†å‡ºæ‰€æœ‰é˜¶ä¹˜å–æ¨¡fact[N]ï¼Œä»¥åŠæ‰€æœ‰é˜¶ä¹˜å–æ¨¡çš„é€†å…ƒinfact[N]ï¼Œå¦‚æœå–æ¨¡çš„æ•°æ˜¯è´¨æ•°ï¼Œå¯ä»¥ç”¨è´¹é©¬å°å®šç†æ±‚é€†å…ƒ
int qmi(int a, int k, int p) {   // å¿«é€Ÿå¹‚æ¨¡æ¿
    ...
}

// é¢„å¤„ç†é˜¶ä¹˜çš„ä½™æ•°å’Œé˜¶ä¹˜é€†å…ƒçš„ä½™æ•°
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ ) {
    fact[i] = fact[i - 1] * i % mod;
    infact[i] = infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}

res = fact[a] * infact[a - b] * infact[b];
```

### Lucas å®šç†

è‹¥ p æ˜¯è´¨æ•°ï¼Œåˆ™å¯¹äºä»»æ„æ•´æ•° $1 <= m <= n$ï¼Œæœ‰ï¼š
$$
C_{a}^{b}â‰¡C_{a\mod p}^{b\mod p}\cdot C_{a|p}^{b|p}(mod\,p)
$$

```java
int qmi(int a, int k) {      // å¿«é€Ÿå¹‚æ¨¡æ¿
    ...
}

long C(int a, int b) {    // é€šè¿‡å®šç†æ±‚ç»„åˆæ•°C(a, b)
    long res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- ) {
        res = res * j % p;
        res = res * qmi(i, p - 2) % p;
    }
    return long;
}

long lucas(LL a, LL b) {
    if (a < p) return C(a, b);
    return C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```

### åˆ†è§£è´¨å› æ•°æ³•æ±‚ç»„åˆæ•°

```java
å½“æˆ‘ä»¬éœ€è¦æ±‚å‡ºç»„åˆæ•°çš„çœŸå®å€¼ï¼Œè€Œéå¯¹æŸä¸ªæ•°çš„ä½™æ•°æ—¶ï¼Œåˆ†è§£è´¨å› æ•°çš„æ–¹å¼æ¯”è¾ƒå¥½ç”¨ï¼š
    1. ç­›æ³•æ±‚å‡ºèŒƒå›´å†…çš„æ‰€æœ‰è´¨æ•°
    2. é€šè¿‡ C(a, b) = a! / b! / (a - b)! è¿™ä¸ªå…¬å¼æ±‚å‡ºn!ä¸­æ¯ä¸ªè´¨å› å­çš„æ¬¡æ•°ã€‚ n!ä¸­pçš„æ¬¡æ•°æ˜¯ n / p + n / p^2 + n / p^3 + ...
    3. ç”¨é«˜ç²¾åº¦ä¹˜æ³•å°†æ‰€æœ‰è´¨å› å­ç›¸ä¹˜
```

```java
int primes[N], cnt;     // å­˜å‚¨æ‰€æœ‰è´¨æ•°
int sum[N];     // å­˜å‚¨æ¯ä¸ªè´¨æ•°çš„æ¬¡æ•°
bool st[N];     // å­˜å‚¨æ¯ä¸ªæ•°æ˜¯å¦å·²è¢«ç­›æ‰

void get_primes(int n) {     // çº¿æ€§ç­›æ³•æ±‚ç´ æ•°
    ...
}

int get(int n, int p) {      // æ±‚n!çš„ç´ å› æ•°pçš„æ¬¡æ•°
    int res = 0;
    while (n ï¼= 0) {
        res += n / p;
        n /= p;
    }
    return res;
}

get_primes(a);  // é¢„å¤„ç†èŒƒå›´å†…çš„æ‰€æœ‰è´¨æ•°

for (int i = 0; i < cnt; i ++ ) {    // æ±‚æ¯ä¸ªè´¨å› æ•°çš„æ¬¡æ•°
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

BigInteger res = BigInteger.valueOf(1);

for (int i = 0; i < cnt; i ++ )     // ç”¨é«˜ç²¾åº¦ä¹˜æ³•å°†æ‰€æœ‰è´¨å› å­ç›¸ä¹˜
    int p = primes[i];
    for (int j = 0; j < sum[i]; j ++ )
        res = res.multiply(BigInteger.valueOf(p));
```

### å¡ç‰¹å…°æ•°

ç»™å®š n ä¸ª 0 å’Œ n ä¸ª 1ï¼Œå®ƒä»¬æŒ‰ç…§æŸç§é¡ºåºæ’æˆé•¿åº¦ä¸º 2n çš„åºåˆ—ï¼Œæ»¡è¶³ä»»æ„å‰ç¼€ä¸­ 0 çš„ä¸ªæ•°éƒ½ä¸å°‘äº 1 çš„ä¸ªæ•°çš„åºåˆ—çš„æ•°é‡ä¸ºï¼š $Cat(n) = C(2n, n) / (n + 1)$

### å®¹æ–¥åŸç†

æŠ€å·§ï¼šç”¨äºŒè¿›åˆ¶è¡¨ç¤ºé›†åˆè¢«æ˜¯å¦é€‰ä¸­çš„çŠ¶æ€



## åšå¼ˆè®º

### Nim æ¸¸æˆ

å®šç†ï¼š Nim åšå¼ˆå…ˆæ‰‹å¿…èƒœï¼Œå½“ä¸”ä»…å½“ A1 ^ A2 ^ â€¦ ^ An != 0

### Mex è¿ç®—

è®¾ S è¡¨ç¤ºä¸€ä¸ªéè´Ÿæ•´æ•°é›†åˆã€‚å®šä¹‰ mex(S) ä¸ºæ±‚å‡ºä¸å±äºé›†åˆ S çš„æœ€å°éè´Ÿæ•´æ•°çš„è¿ç®—ï¼Œå³ï¼š
mex(S) = min{x}, x å±äºè‡ªç„¶æ•°ï¼Œä¸” x ä¸å±äº S

### SG å‡½æ•°

åœ¨æœ‰å‘å›¾æ¸¸æˆä¸­ï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹ xï¼Œè®¾ä» x å‡ºå‘å…±æœ‰ k æ¡æœ‰å‘è¾¹ï¼Œåˆ†åˆ«åˆ°è¾¾èŠ‚ç‚¹ y1, y2, â€¦, ykï¼Œå®šä¹‰ SG(x) ä¸º x çš„åç»§èŠ‚ç‚¹ y1, y2, â€¦, yk çš„ SG å‡½æ•°å€¼æ„æˆçš„é›†åˆå†æ‰§è¡Œ mex(S) è¿ç®—çš„ç»“æœï¼Œå³ï¼š
SG(x) = mex({SG(y1), SG(y2), â€¦, SG(yk)})
ç‰¹åˆ«åœ°ï¼Œæ•´ä¸ªæœ‰å‘å›¾æ¸¸æˆ G çš„ SG å‡½æ•°å€¼è¢«å®šä¹‰ä¸ºæœ‰å‘å›¾æ¸¸æˆèµ·ç‚¹ s çš„ SG å‡½æ•°å€¼ï¼Œå³ SG(G) = SG(s)ã€‚

```java
int f[M],p[N];// på­˜å¯ä¾›é€‰æ‹©çš„é›†åˆ,få­˜sgå€¼
int sg(int x){
    if(f[x] != -1)  return f[x]; // è®°å¿†åŒ–æœç´¢ï¼Œå¦‚æœf[x]å·²ç»è¢«è®¡ç®—è¿‡ï¼Œåˆ™ç›´æ¥è¿”å›
    							 // å› ä¸ºå¯å–æ•°ç›®çš„é›†åˆå·²ç»ç¡®å®š,æ‰€ä»¥æ¯ä¸ªæ•°çš„sgå€¼ä¹Ÿæ˜¯ç¡®å®šçš„
    Set<Integer> set = new HashSet<>();
    for(int i = 0; i < n ; i ++ ){ 
        if(x >= p[i]) set.add(sg(x - p[i]));  // å¦‚æœå¯ä»¥æ‹¿èµ°p[i]ä¸ª
    }
    // æ±‚mex()
    for(int i = 0 ; ;i ++ ){
        if(!set.contains(i)){
            return f[x] = i;
        }
    }
}
```



# åŠ¨æ€è§„åˆ’

![image.png](https://s2.loli.net/2024/07/13/DJTSgWswYc1Pv4y.png)

### çº¿æ€§DP



### åŒºé—´DP

æŒ‰åŒºé—´é•¿åº¦ä»å°åˆ°å¤§æšä¸¾
